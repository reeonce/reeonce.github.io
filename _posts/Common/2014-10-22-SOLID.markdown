---
layout: post
title: First Five Principles in OOP - SOLID
category: common
tags: [OOP, SOLID]
date: 2014-10-22
---


#### Single responsibility principle

A class should have only a single responsibility (i.e. only one potential change in the software's specification should be able to affect the specification of the class). A responsibility is a reason to change, which means a class or module should have one, and only one, reason to change. 

As an example, consider a module that compiles and prints a report. Such a module can be changed for two reasons. First, the content of the report can change. Second, the format of the report can change. These two things change for very different causes; one substantive, and one cosmetic. The single responsibility principle says that these two aspects of the problem are really two separate responsibilities, and should therefore be in separate classes or modules. It would be a bad design to couple two things that change for different reasons at different times.

#### Open/closed principle

software entities (classes, modules, functions, etc.) should be open for extension, but closed for modification.

An entity can allow its behaviour to be extended without modifying its source code. This is especially valuable in a production environment, where changes to source code may necessitate code reviews, unit tests, and other such procedures to qualify it for use in a product: code obeying the principle doesn't change when it is extended, and therefore needs no such effort.

#### Liskov substitution principle

Liskov's notion of a behavioral subtype defines a notion of substitutability for mutable objects; that is, if S is a subtype of T, then objects of type T in a program should be replaceable with instances of S without altering the correctness of that program.

#### Interface segregation principle

Many client-specific interfaces are better than one general-purpose interface.

ISP splits interfaces which are very large into smaller and more specific ones so that clients will only have to know about the methods that are of interest to them. 

#### Dependency inversion principle

One should “Depend upon Abstractions. Do not depend upon concretions.”

When following this principle, the conventional dependency relationships established from high-level, policy-setting modules to low-level, dependency modules are inverted (i.e. reversed), thus rendering high-level modules independent of the low-level module implementation details. The principle states

> A. High-level modules should not depend on low-level modules. Both should depend on abstractions.

> B. Abstractions should not depend on details. Details should depend on abstractions.

The principle inverts the way some people may think about object-oriented design, dictating that both high- and low-level objects must depend on the same abstraction.


#### References:

[SOLID (object-oriented design)](http://en.wikipedia.org/wiki/SOLID_(object-oriented_design))